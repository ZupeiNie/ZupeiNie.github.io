<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DFA-AP</title>
    <url>/2025/03/24/DFA-AP/</url>
    <content><![CDATA[<h1>DFA-AP</h1>
<h2 id="数据流分析总揽">数据流分析总揽</h2>
<p>数据流分析的核心：How Data Flows on CFG?</p>
<p>将这句话展开来，所谓数据流分析就是：</p>
<p>How application-specific Data (对数据的抽象：+, -, 0 等……)</p>
<p>Flows (根据分析的类型，做出合适的估算) through the</p>
<p>Nodes (数据如何 transfer, 如 + op + = +) and</p>
<p>Edges (控制流如何处理，例如两个控制流汇入一个BB) of</p>
<p>CFG (整个程序) ?</p>
<p>不同的数据流分析，有着不同的data abstraction, flow safe-approximation策略，transfer functions&amp;control-flow handlings。</p>
<p><code>may analysis ：outputs information that may be true(over-approximation)</code></p>
<p>May analysis 关注程序中可能发生的行为，即分析的结果是程序中所有可能会发生的情况的<strong>上界</strong>，输出结果可能为真，可能引入假阳性（实际未发生也被标记为可能）</p>
<p><code>must analysis:outputs information that must be true(under-approximation)</code></p>
<p>Must analysis 关注程序中一定会发生的行为，即分析的结果是程序所有行为的<strong>下界</strong>，输出结果必须为真，可能引入假阴性（漏掉实际发生的情况）</p>
<p><code>Over- and under-approximations are both for safety of analysis.</code></p>
<p>Over-approximation（May Analysis）：为了避免遗漏潜在的危险行为，may analysis 通常牺牲精确性来涵盖所有可能性。这在安全性分析中非常重要，因为任何可能的漏洞都不能被忽略。</p>
<p>Under-approximation（Must Analysis）：强调分析结果的可信度和可靠性，即分析所证明的属性一定是真实的。这对验证某些安全性条件是否始终满足非常关键。</p>
<h2 id="数据流分析的初步准备">数据流分析的初步准备</h2>
<p>1.Input and Output States 输入输出状态</p>
<ul>
<li>每一条IR的执行，都会使状态从<strong>输入状态</strong>变成新的<strong>输出状态</strong></li>
<li>输入/输出状态与语句前/后的 <strong>program point</strong> 相关联。</li>
</ul>
<p>2.关于转移方程约束的概念</p>
<p>分析数据流有前向和后向两种</p>
<img src="/2025/03/24/DFA-AP/数据流前后向.jpeg" alt="数据流前后向" style="zoom:25%;">
<p>3.不会涉及到的概念</p>
<ul>
<li>函数调用 Method Calls
<ul>
<li>我们将分析的是过程本身中的事情，即 Intra-procedural。而过程之间的分析，将在 Inter-procedural Analysis 中介绍</li>
</ul>
</li>
<li>变量别名 Aliases
<ul>
<li>变量不能有别名。有关问题将在指针分析中介绍。</li>
</ul>
</li>
</ul>
<h2 id="Reaching-Definitions-Analysis-到达定值分析">Reaching Definitions Analysis 到达定值分析</h2>
<h3 id="定义">定义</h3>
<p><code>Reaching Definitions：A definition d at program point p reaches a point q if there is a path from p to q such that d is not &quot;killed&quot; along that path.</code></p>
<p>定义（许畅-编译原理）：假定 x 有定值 d (<strong>definition</strong>)，如果存在一个路径，从紧随 d 的点到达某点 p，并且此路径上面没有 x 的其他定值点，则称 x 的定值 d 到达 (<strong>reaching</strong>) p。如果在这条路径上有对 x 的其它定值，我们说变量 x 的这个定值 d 被杀死 (<strong>killed</strong>) 了</p>
<img src="/2025/03/24/DFA-AP/到达定值分析定义.jpeg" alt="到达定值分析定义" style="zoom:30%;">
<h3 id="到达定值中的数据流值">到达定值中的数据流值</h3>
<ul>
<li>程序中所有变量的定值。</li>
<li>可以用一个 bit vector 来定义，有多少个赋值语句，就有多少个位。</li>
</ul>
<img src="/2025/03/24/DFA-AP/到达定值数据流值.png" alt="到达定值数据流值" style="zoom:40%;">
<h3 id="到达定值的转移方程和控制流处理">到达定值的转移方程和控制流处理</h3>
<p><code>That statement &quot;generates&quot; a definition D of variable v and &quot;kills&quot; a;; the other definitions in the program that define variable v, while leaving the remaining incoming definitions unaffected. </code></p>
<p>语句 S 对变量 v 创建了一个新定义 D（即该语句定义了 v）。该定义 D 会取代程序中所有对 v 的旧定义，这些旧定义在 S 执行后变得无效（被“杀死”）。但是，程序中与变量 v 无关的其他变量的定义不会受影响，仍然保留原样。</p>
<p>Transfer function:从入口状态删除 kill 掉的定值，并加入新生成的定值；v = x op y，gen v, kill 其它所有的 v</p>
<p>control flow:任何一个前驱的变量定值都表明，该变量得到了定义。</p>
<img src="/2025/03/24/DFA-AP/到达定值的转移方程.jpeg" alt="到达定值的转移方程" style="zoom:33%;">
<h3 id="到达定值算法">到达定值算法</h3>
<p><img src="/2025/03/24/DFA-AP/%E5%88%B0%E8%BE%BE%E5%AE%9A%E5%80%BC%E7%AE%97%E6%B3%95.jpeg" alt="到达定值算法"></p>
<p>这是一个经典的迭代算法。</p>
<ul>
<li>首先让所有BB和入口的OUT为空。因为你不知道 BB 中有哪些定值被生成。</li>
<li>当任意 OUT 发生变化，则分析出的定值可能需要继续往下流动，所需要修改各 BB 的 IN 和 OUT。</li>
<li>先处理 IN，然后再根据转移完成更新 OUT。</li>
<li>在 gen U (IN - kill) 中，kill 与 gen 相关的 bit 不会因为 IN 的改变而发生改变，而其它 bit 又是通过对前驱 OUT 取并得到的，因此其它 bit 不会发生 0 -&gt; 1 的情况。所以，OUT 是不断增长的，而且有上界，因此算法最后必然会停止。</li>
<li>因为 OUT 没有变化，不会导致任何的 IN 发生变化，因此 OUT 不变可以作为终止条件。我们称之为程序到达了不动点（Fixed Point）</li>
<li>union为并集的意思，即有1为1，全0为0。</li>
<li>计算抽象说明就是在in上将gen的改为1，将kill的改为0。</li>
</ul>
<p><img src="/2025/03/24/DFA-AP/%E5%88%B0%E8%BE%BE%E5%AE%9A%E5%80%BC%E7%AE%97%E6%B3%95%E4%BE%8B%E5%AD%901.jpeg" alt="到达定值算法例子1"></p>
<p>说明：初始定义所有BB的out为全0，之后从上至下依次根据公式更新。此时分析B2的out，注意到B2的in为B1的out和B4的out的union，故要先做union在继续分析B2的out。此时B2的in为11000000 U 00000000 = 11000000，gen为B2自身涉及的D3、D4即00110000，kill为之前涉及的D2（y）即01000000，故结果为00110000 U (11000000-01000000) = 10110000。</p>
<p><img src="/2025/03/24/DFA-AP/%E5%88%B0%E8%BE%BE%E5%AE%9A%E5%80%BC%E7%AE%97%E6%B3%95%E4%BE%8B%E5%AD%902.jpeg" alt="到达定值算法例子2"></p>
<p>说明：此时分析B3的out，in为B2的out即10110000，gen为B3自身涉及的D7即00000010，kill为B3涉及到之前的D1（x）即10000000，故结果为00000010 U (10110000-10000000) = 00110010。</p>
<p><img src="/2025/03/24/DFA-AP/%E5%88%B0%E8%BE%BE%E5%AE%9A%E5%80%BC%E7%AE%97%E6%B3%95%E4%BE%8B%E5%AD%903.jpeg" alt="到达定值算法例子3"></p>
<p>说明：经过3轮迭代计算，所有BB的out没有改变，此时到达不动点，算法结束。</p>
<p><img src="/2025/03/24/DFA-AP/%E5%88%B0%E8%BE%BE%E5%AE%9A%E5%80%BC%E7%AE%97%E6%B3%95%E6%9C%80%E7%BB%88%E4%BC%9A%E5%81%9C%E5%8E%9F%E5%9B%A0.jpeg" alt="到达定值算法最终会停原因"></p>
<h3 id="算法一定会停原因">算法一定会停原因</h3>
<p>单调性：OUT[S] 不会缩减</p>
<ul>
<li>每次迭代时：
<ul>
<li>$gen_S$ 和 $kill_S$ 是固定不变的。</li>
<li>$OUT[S]$ 只会因为新增的 $gen_S$ 或 $ survivors$ 增加新的事实，但不会减少已有事实。</li>
<li>因此，$OUT[S]$ 是一个单调增长的集合。</li>
</ul>
</li>
</ul>
<p>有限性：事实集合大小有限</p>
<ul>
<li>程序中的所有变量定义是有限的，因此整个程序中的事实集合是有限的。</li>
<li>$OUT[S]$ 不可能无限增加，因为程序中事实总数是有限的。</li>
</ul>
<p>收敛性：新增事实最终停止</p>
<ul>
<li>当所有 $OUT[S]$ 在某次迭代中不再有新事实加入时（即不再有新增的 $gen_S$ 或 $survivors$），算法达到收敛。</li>
<li>由于 $OUT[S]$ 永不缩减且集合有限，算法总会收敛到一个固定点（即最终的结果）。</li>
</ul>
<h2 id="Live-Variables-Analysis-活跃变量分析">Live Variables Analysis 活跃变量分析</h2>
<h3 id="定义-2">定义</h3>
<p><code>Live variables analysis tells whether the value of variable v at program point p could be used along some path in CFG starting at p. If so, v is live at p;otherwise, v is dead at p.</code></p>
<ul>
<li>变量 x 在程序点 p 上的值是否会在某条从 p 出发的路径中使用。</li>
<li>变量 x 在 p 上活跃，当 且仅存在一条从 p 开始的路径，该路径的末端使用了 x，且路径上没有对 x进行覆盖。</li>
<li>隐藏了这样一个含义：在被使用前，v 没有被重新定义过，即没有被 kill 过。</li>
</ul>
<img src="/2025/03/24/DFA-AP/活跃变量分析定义.jpeg" alt="活跃变量分析定义" style="zoom:30%;">
<p>这个算法可以用于寄存器分配，当一个变量不会再被使用，那么此变量就可以从寄存器中腾空，用于新值的存储。</p>
<p>使用backward后向分析来处理活跃变量分析更方便</p>
<h3 id="活跃变量中的数据流值">活跃变量中的数据流值</h3>
<ul>
<li>程序中的所有变量</li>
<li>依然可以用 bit vector 来表示，每个 bit 代表一个变量</li>
</ul>
<img src="/2025/03/24/DFA-AP/活跃变量中的数据流值.png" alt="活跃变量中的数据流值" style="zoom:40%;">
<h3 id="活跃变量的转移方程和控制流处理">活跃变量的转移方程和控制流处理</h3>
<p><img src="/2025/03/24/DFA-AP/%E6%B4%BB%E8%B7%83%E5%8F%98%E9%87%8F%E5%88%86%E6%9E%90%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B%E5%92%8C%E6%8E%A7%E5%88%B6%E6%B5%81%E5%A4%84%E7%90%86.jpeg" alt="活跃变量分析转移方程和控制流处理"></p>
<ul>
<li>一个基本块内，若 v = exp, 则 def v。若 exp = exp op v，那么 use v。一个变量要么是 use，要么是 def，根据 def 和 use 的先后顺序来决定。</li>
<li>考虑基本块 B 及其后继 S。若 S 中，变量 v 被使用，那么我们就把 v 放到 S 的 IN 中，交给 B 来分析。</li>
<li>因此对于活跃变量分析，其控制流处理是 OUT[B] = IN[S]。</li>
<li>在一个块中，若变量 v 被使用，那么我们需要添加到我们的 IN 里。而如果 v 被定义，那么在其之上的语句中，v 都是一个非活跃变量，因为没有语句再需要使用它。</li>
<li>因此对于转移方程，IN 是从 OUT 中删去重新定值的变量，然后并上使用过的变量。需要注意，如果同一个块中，变量 v 的 def 先于 use ，那么实际上效果和没有 use 是一样的。</li>
<li>注意use和def的顺序，如图中的4和6。</li>
</ul>
<h3 id="活跃变量算法">活跃变量算法</h3>
<p><img src="/2025/03/24/DFA-AP/%E6%B4%BB%E8%B7%83%E5%8F%98%E9%87%8F%E7%AE%97%E6%B3%95.jpeg" alt="活跃变量算法"></p>
<ul>
<li>我们不知道块中有哪些活跃变量，而且我们的目标是知道在一个块开始时哪些变量活跃，因此把 IN 初始化为空。</li>
<li>计算过程类似上文到达定值算法。</li>
<li>初始化的判断技巧：may analysis 是空（全0），must analysis 是 top（全1）。</li>
<li>计算抽象说明就是在out上将use的改为1，def的改为0。</li>
</ul>
<p><img src="/2025/03/24/DFA-AP/%E6%B4%BB%E8%B7%83%E5%8F%98%E9%87%8F%E7%AE%97%E6%B3%95%E4%BE%8B%E5%AD%901.jpeg" alt="活跃变量算法例子1"></p>
<p>说明：算法初始化所有BB的in为全0，自下而上的迭代分析。此时需要分析B3的in，out为B5的in即0001000，use为B3自身涉及的x（注意这个表达式x=x-3，此时x为先use后def，故而仍然算是use并且def为0000000）即1000000，故而in为1000000 U (0001000 - 0000000) = 1001000。</p>
<p><img src="/2025/03/24/DFA-AP/%E6%B4%BB%E8%B7%83%E5%8F%98%E9%87%8F%E7%AE%97%E6%B3%95%E4%BE%8B%E5%AD%902.jpeg" alt="活跃变量算法例子2"></p>
<p>说明：此时分析B4的in，注意到B4的out有两个，需要先union，0001000（B5的in）U 0000000（初始值）= 0001000，use为B4涉及的y即0100000，def为x即1000000，故而in为0100000 U (0001000 - 1000000) = 0101000。</p>
<p><img src="/2025/03/24/DFA-AP/%E6%B4%BB%E8%B7%83%E5%8F%98%E9%87%8F%E7%AE%97%E6%B3%95%E4%BE%8B%E5%AD%903.jpeg" alt="活跃变量算法例子3"></p>
<p>说明：经过3轮迭代计算，所有BB的in都没有改变，算法结束。</p>
<h2 id="Available-Expression-Analysis-可用表达式分析">Available Expression Analysis 可用表达式分析</h2>
<h3 id="定义-3">定义</h3>
<p><code>An expression x op y is a available at program point p if (1) all paths from the entry to p must pass through the evaluation of x op y, and (2) after the last evaluation of x op y, there is no redefinition of x op y.</code></p>
<p>x + y 在 p 点可用的条件：从流图入口结点到达 p 的每条路径都对 x + y 求了值，且在最后一次求值之后再没有对 x 或 y 赋值</p>
<p>可用表达式可以用于全局公共子表达式的计算。也就是说，如果一个表达式上次计算的值到这次仍然可用，我们就能直接利用其中值，而不用进行再次的计算。</p>
<h3 id="可用表达式分析中的数据流值">可用表达式分析中的数据流值</h3>
<ul>
<li>程序中的所有表达式</li>
<li>bit vector 中，一个 bit 就是一个表达式</li>
</ul>
<img src="/2025/03/24/DFA-AP/可用表达式的数据流值.png" alt="可用表达式的数据流值" style="zoom:40%;">
<h3 id="可用表达式的转移方程和控制流处理">可用表达式的转移方程和控制流处理</h3>
<p><img src="/2025/03/24/DFA-AP/%E5%8F%AF%E7%94%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B%E5%92%8C%E6%8E%A7%E5%88%B6%E6%B5%81%E5%A4%84%E7%90%86.jpeg" alt="可用表达式的转移方程和控制流处理"></p>
<ul>
<li>我们要求无论从哪条路径到达 B，表达式都应该已经计算，才能将其视为可用表达式，因此这是一个 must analysis。</li>
<li>注意到图中，两条不同的路径可能会导致表达式的结果最终不一致。但是我们只关心它的值能不能够再被重复利用，因此可以认为表达式可用。</li>
<li>v = x op y，则 gen x op y。当 x = a op b，则任何包含 x 的表达式都被 kill 掉。若 gen 和 kill 同时存在，那么以最后一个操作为准。</li>
<li>转移方程很好理解，和到达定值差不多。但是，由于我们是 must analysis，因此控制流处理是取交集，而非到达定值那样取并集。</li>
<li>注意gen和kill的顺序，先kill后gen还是gen。</li>
</ul>
<h3 id="可用表达式的算法">可用表达式的算法</h3>
<p><img src="/2025/03/24/DFA-AP/%E5%8F%AF%E7%94%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%AE%97%E6%B3%95.jpeg" alt="可用表达式的算法"></p>
<ul>
<li>注意此时的初始化：一开始确实无任何表达式可用，因此OUT[entry]被初始化为空集是自然的。但是，其它基本块的 OUT 被初始化为全集，这是因为当 CFG 存在环时，一个空的初始化值，会让取交集阶段直接把第一次迭代的 IN 设置成 0，无法进行正确的判定了。</li>
<li>如果一个表达式从来都不可用，那么OUT[entry]的全 0 值会通过交操作将其置为 0，因此不用担心初始化为全 1 会否导致算法不正确。</li>
<li>计算抽象说明就是在out上将gen的改为1，kill的改为0。</li>
</ul>
<p><img src="/2025/03/24/DFA-AP/%E5%8F%AF%E7%94%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%AE%97%E6%B3%95%E4%BE%8B%E5%AD%901.jpeg" alt="可用表达式的算法例子1"></p>
<p>说明：初始化entry处的out为全0，其他为全1。此时需要分析B2的out，注意到B2的in有两部分，取两部分的交集即10000，gen为B2自身涉及的z/5、e^7*x即01010，kill为B2涉及的p即10000，故而out为01010 U (10000 - 10000) = 01010。</p>
<p><img src="/2025/03/24/DFA-AP/%E5%8F%AF%E7%94%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%AE%97%E6%B3%95%E4%BE%8B%E5%AD%902.jpeg" alt="可用表达式的算法例子2"></p>
<p>说明：此时分析B4的out，in为B2的out即01010，gen为B4自身涉及的2*y、e^7*x(注意这里是先kill后gen)即00110，kill为00000，故而out为01010 U (00110 - 00000) = 01110。</p>
<p><img src="/2025/03/24/DFA-AP/%E5%8F%AF%E7%94%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%AE%97%E6%B3%95%E4%BE%8B%E5%AD%903.jpeg" alt="可用表达式的算法例子3"></p>
<p>说明：经过2轮迭代计算，所有BB的out都没有改变，算法结束。</p>
<h2 id="三种数据流分析总结">三种数据流分析总结</h2>
<p><img src="/2025/03/24/DFA-AP/%E4%B8%89%E7%A7%8D%E6%95%B0%E6%8D%AE%E6%B5%81%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93%E5%AF%B9%E6%AF%94.jpeg" alt="三种数据流分析总结对比"></p>
<h3 id="分析目标">分析目标</h3>
<ul>
<li><strong>Reaching Definitions（到达定义分析）</strong>：<br>
分析程序中每个基本块的定义信息（哪些变量的定义可以从前面流入当前块）。</li>
<li><strong>Live Variables（活跃变量分析）</strong>：<br>
分析程序中每个基本块的活跃变量（哪些变量的值在未来可能被使用，需保留其定义）。</li>
<li><strong>Available Expressions（可用表达式分析）</strong>：<br>
分析程序中每个基本块的表达式信息（哪些表达式在当前块之前已经计算且未被修改，可以直接复用）。</li>
</ul>
<h3 id="分析方向">分析方向</h3>
<ul>
<li><strong>Reaching Definitions</strong>：<strong>前向分析</strong>（Forwards）<br>
从程序的入口点向后传播，计算哪些定义到达了当前基本块。</li>
<li><strong>Live Variables</strong>：<strong>后向分析</strong>（Backwards）<br>
从程序的出口点向前传播，计算哪些变量在未来的基本块中会被使用。</li>
<li><strong>Available Expressions</strong>：<strong>前向分析</strong>（Forwards）<br>
从程序的入口点向后传播，计算哪些表达式在当前块可以直接复用。</li>
</ul>
<h3 id="May-Must-属性">May / Must 属性</h3>
<ul>
<li><strong>Reaching Definitions</strong>：<strong>May Analysis</strong>
<ul>
<li>关心“某些定义可能到达当前块”。</li>
<li>结果是所有可能的定义（宽松的上界）。</li>
</ul>
</li>
<li><strong>Live Variables</strong>：<strong>May Analysis</strong>
<ul>
<li>关心“某些变量可能在未来使用”。</li>
<li>结果是所有可能活跃的变量（宽松的上界）。</li>
</ul>
</li>
<li><strong>Available Expressions</strong>：<strong>Must Analysis</strong>
<ul>
<li>关心“某些表达式必须在当前块可用”。</li>
<li>结果是所有必须可用的表达式（严格的下界）。</li>
</ul>
</li>
</ul>
<h3 id="边界条件（Boundary-Condition）">边界条件（Boundary Condition）</h3>
<ul>
<li><strong>Reaching Definitions</strong>：
<ul>
<li>$OUT[entry] = \varnothing$（入口点没有到达的定义）。</li>
</ul>
</li>
<li><strong>Live Variables</strong>：
<ul>
<li>$IN[exit] = \varnothing$（程序出口没有活跃变量，因为没有后续的使用）。</li>
</ul>
</li>
<li><strong>Available Expressions</strong>：
<ul>
<li>$OUT[entry] = \varnothing$（入口点没有可用表达式）。</li>
</ul>
</li>
</ul>
<h3 id="初始化（Initialization）">初始化（Initialization）</h3>
<ul>
<li><strong>Reaching Definitions</strong>:
<ul>
<li>初始化 $OUT[B] = \varnothing$（默认没有到达的定义）。</li>
</ul>
</li>
<li><strong>Live Variables</strong>:
<ul>
<li>初始化 $IN[B] = \varnothing$（默认没有活跃变量）。</li>
</ul>
</li>
<li><strong>Available Expressions:</strong>
<ul>
<li>初始化 $OUT[B] = U$（所有表达式都被假定为可用，直到证伪）。</li>
</ul>
</li>
</ul>
<h3 id="传递函数（Transfer-Function）">传递函数（Transfer Function）</h3>
<ul>
<li>
<p>所有分析都基于以下公式的传递规则：</p>
<p>$OUT[B] = gen_B \cup (IN[B] - kill_B)$</p>
<ul>
<li>$gen_B$：表示在当前基本块中生成的新信息。</li>
<li>$kill_B$：表示在当前基本块中被覆盖或无效的信息。</li>
</ul>
</li>
</ul>
<h3 id="合并操作（Meet-Operation）">合并操作（Meet Operation）</h3>
<ul>
<li><strong>Reaching Definitions</strong> 和 <strong>Live Variables</strong>：<br>
合并操作是<strong>并集（Union）</strong>，即所有可能到达或活跃的信息的集合。</li>
<li><strong>Available Expressions</strong>：<br>
合并操作是<strong>交集（Intersection）</strong>，即所有路径上共同可用的表达式。</li>
</ul>
<h3 id="总结">总结</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>Reaching Definitions</th>
<th>Live Variables</th>
<th>Available Expressions</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>目标</strong></td>
<td>变量定义到达情况</td>
<td>变量活跃情况</td>
<td>可用表达式情况</td>
</tr>
<tr>
<td><strong>分析方向</strong></td>
<td>前向（Forwards）</td>
<td>后向（Backwards）</td>
<td>前向（Forwards）</td>
</tr>
<tr>
<td><strong>May / Must</strong></td>
<td>May</td>
<td>May</td>
<td>Must</td>
</tr>
<tr>
<td><strong>边界条件</strong></td>
<td>$OUT[entry] = \varnothing$</td>
<td>$IN[exit] = \varnothing$</td>
<td>$OUT[entry] = \varnothing$</td>
</tr>
<tr>
<td><strong>初始化</strong></td>
<td>$OUT[B] = \varnothing$</td>
<td>$IN[B] = \varnothing$</td>
<td>$OUT[B] = U$</td>
</tr>
<tr>
<td><strong>传递函数</strong></td>
<td>$OUT = gen \cup (IN - kill)$</td>
<td>同左</td>
<td>同左</td>
</tr>
<tr>
<td><strong>合并操作</strong></td>
<td>并集（Union）</td>
<td>并集（Union）</td>
<td>交集（Intersection）</td>
</tr>
</tbody>
</table>
<p>每种分析都为程序优化提供不同的信息：</p>
<ul>
<li><strong>Reaching Definitions</strong> 支持常量传播、死代码消除等。</li>
<li><strong>Live Variables</strong> 支持寄存器分配、内存优化。</li>
<li><strong>Available Expressions</strong> 支持公共子表达式消除等优化。</li>
</ul>
<h2 id="参考">参考</h2>
<p><a href="https://www.bilibili.com/video/BV1oE411K79d?spm_id_from=333.788.videopod.sections&amp;vd_source=068a446a106a7db814d0a819ae62f901">南京大学《软件分析》课程03（Data Flow Analysis I）_哔哩哔哩_bilibili</a></p>
<p><a href="https://www.bilibili.com/video/BV19741197zA?spm_id_from=333.788.videopod.sections&amp;vd_source=068a446a106a7db814d0a819ae62f901">南京大学《软件分析》课程04（Data Flow Analysis II）_哔哩哔哩_bilibili</a></p>
<p><a href="https://ranger-nju.gitbook.io/static-program-analysis-book/ch1/34dataflowanalysis">数据流分析上 | Static Program Analysis Book (gitbook.io)</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>SPA</tag>
      </tags>
  </entry>
  <entry>
    <title>DFA-FD</title>
    <url>/2025/03/24/DFA-FD/</url>
    <content><![CDATA[<h2 id="DFA-FD">DFA-FD</h2>
<h3 id="Iterative-Algorithm-Another-View">Iterative Algorithm, Another View</h3>
<p>给定一个有 k 个节点的 CFG，迭代算法会更新每个节点 n 的 OUT[n] 值。那么就可以考虑把这些值定义为一个 k-tuple：</p>
<p>$(OUT[n_1],OUT[n_2],…,OUT[n_k])∈(V_1×V_2×…×V_k)=V_k$</p>
<p>则，我们的数据流分析迭代算法框架就可记为$F:V^k \rightarrow V^k$</p>
<p>迭代过程就被记为：</p>
<ul>
<li>$X_0 = (null, null, …, null)$</li>
<li>$X_1 = (v_1^1,v_2^1,…,v_k^1) = F(X_0)$</li>
<li>$X_2 = (v_1^2,v_2^2,…,v_k^2) = F(X_1)$</li>
<li>…</li>
<li>$X_i = (v_1^i,v_2^i,…,v_k^i) = F(X_{i-1})$</li>
<li>$X_{i+1} = (v_1^i,v_2^i,…,v_k^i) = F(X_{i})$</li>
<li>此时我们发现$X_i =X_{i+1}$，意味着$X_i$就是$F$的一个不动点。</li>
</ul>
<p>在这个框架下，我们就有一些想知道的问题：</p>
<ul>
<li>Is the algorithm guaranteed to terminate or reach the fixed point, or does it always have a solution?</li>
<li>If so, is there only one solution or only one fixed point? If more than one, is our solution the best one (most precise)?</li>
<li>When will the algorithm reach the fixed point, or when can wo get the solution?</li>
</ul>
<p>即：</p>
<ul>
<li>算法是否确保一定能停止/达到不动点？会不会总是有一个解答？</li>
<li>如果能到达不动点，那么是不是只有一个不动点？如果有多个不动点，我们的结果是最优的吗？</li>
<li>什么时候我们会能得到不动点？</li>
</ul>
<h3 id="Partial-Order">Partial Order</h3>
<p>所谓偏序集合（poset），就是一个由集合 $P$ 和偏序关系$\sqsubseteq$所组成$(P, \sqsubseteq)$对。这个对满足以下三个条件：</p>
<ul>
<li>Reflexivity 自反性：x $\sqsubseteq$ x</li>
<li>Antisymmetry 反对称性：x $\sqsubseteq$ y, y $\sqsubseteq$ x, 则 x = y</li>
<li>Transitivity 传递性：x $\sqsubseteq$ y, y $\sqsubseteq$ z, 则 x $\sqsubseteq$ z</li>
<li>例子：小于等于关系就是一个偏序关系，但小于关系不是偏序关系，它是全序关系。</li>
</ul>
<p>偏序关系与全序关系的区别在于，全序关系可以让任意两个元素比较，而偏序关系不保证所有元素都能进行比较。</p>
<h3 id="Upper-and-Lower-Bounds">Upper and Lower Bounds</h3>
<p>对于偏序集中的某子集 S 来说：</p>
<ul>
<li>若存在元素 u 使得 S 的任意元素 x 有 x $\sqsubseteq$ u，那么我们说 u 是 S 的上界（Upper bound）。</li>
<li>同理，若存在元素 l 使得 S 的任意元素 x 有 l $\sqsubseteq$ x，那么我们说 l 是 S 的下界（Lower bound）。</li>
</ul>
<p>然后我们衍生出最小上界和最大下界的概念：</p>
<ul>
<li>在 S 的所有上界中，我们记最小上界（Least upper bound, lub）为$\sqcup S$，满足所有上界 u 对 lub 有： $\sqcup S \sqsubseteq u$</li>
<li>类似地我们也能定义出最大下界（Greatest lower bound, glb）为$\sqcap S$。</li>
</ul>
<img src="/2025/03/24/DFA-FD/上下界例子.jpeg" alt="上下界例子" style="zoom:20%;">
<p>当 S 的元素个数只有两个{a, b}时，我们还可以有另一种记法：</p>
<ul>
<li>最小上界：$a \sqcup b$, a join b</li>
<li>最大下界：$a \sqcap b$, a meet b</li>
</ul>
<p>并不是每个偏序集都有 lub 和 glb，但是如果有，那么该 lub, glb 将是唯一的。（可假设存在多个，然后用自反性证明它们是同一个：假设有两个lub，那其中一个按照定义应该是最小的，那两者中存在一个更小的，和原始定义冲突，故而只能是两者相同即唯一）</p>
<img src="/2025/03/24/DFA-FD/上下界存在则唯一proof.jpeg" alt="上下界存在则唯一proof" style="zoom:20%;">
<h3 id="Lattice-Semilattice-Complete-and-Product-Lattic">Lattice, Semilattice, Complete and Product Lattic</h3>
<p>给定一个偏序集，如果任意元素 a, b 都有 lub和glb，那么这么偏序集就叫做 <strong>格（lattice）</strong>。</p>
<ul>
<li>属于 lattice 的：小于等于关系，子集关系</li>
<li>不属于 lattice 的：子串关系</li>
</ul>
<p>如果偏序集任意两元素的上下界仅有其 lub 和 glb，那么称该偏序集为半格（Semilattice）</p>
<p>如果在此之上更加严格一些，任意集合都存在 lub 和 glb，那么我们说这个 lattice 为 <strong>全格（complete lattice）</strong></p>
<ul>
<li>属于全格的：子集关系</li>
<li>不属于全格的：小于等于关系，因为全体正整数没有一个边界</li>
</ul>
<p>每一个全格都存在着<strong>最大元素$\top$ (top)和最小元素$\bot$ (bottom)</strong>，他们分别是整个集合的 lub 和 glb。</p>
<p>如果一个 lattice 是有穷的，那么它一定是一个全格。然而，一个全格不一定是有穷的，例如[0, 1]之间的实数是无穷的，但是期间的小于等于关系可以使其成为全格。</p>
<p>另外还有 <strong>Product Lattice</strong>，多个 lattice 的笛卡尔积也能形成一个新的 lattice。</p>
<p>需要记住的是：</p>
<ul>
<li>product lattice 也是一个 lattice</li>
<li>如果 product lattice L是全格的积，那么 L 也是全格。</li>
</ul>
<p>Example 1. Is $(S, \sqsubseteq)$ a poset where $S$ is a set of integers and $$\sqsubseteq$$ represents $\leq$ (less than or equal to)?</p>
<p>Example <a href="http://2.Is">2.Is</a>  $(S, \sqsubseteq)$ a poset where $S$ is a set of integers and $$\sqsubseteq$$ represents $&lt;$ (less than)?</p>
<p>Example <a href="http://3.Is">3.Is</a> $(S, \sqsubseteq)$ a poset where $S$ is a set of English words and $$\sqsubseteq$$ represents the substring relation,i.e., $s1 \sqsubseteq s2$ means $s1$ is a substring of $s2$?</p>
<img src="/2025/03/24/DFA-FD/example3.jpeg" alt="example3" style="zoom:20%;">
<p>Example 4. Is  $(S, \sqsubseteq)$ a poset where $S$ is the power set of set ${a,b,c}$ and $\sqsubseteq$ represents $\subseteq$ (subset)?</p>
<img src="/2025/03/24/DFA-FD/example4.jpeg" alt="example4" style="zoom:20%;">
<table>
<thead>
<tr>
<th>example</th>
<th>偏序</th>
<th>格</th>
<th>全格</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>属于</td>
<td>属于</td>
<td>无上界，无穷，不属于全格</td>
</tr>
<tr>
<td>2</td>
<td>不满足自反性</td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>属于</td>
<td>不属于</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>属于</td>
<td>属于</td>
<td>属于</td>
</tr>
</tbody>
</table>
<h3 id="Data-Flow-Analysis-Framework-via-Lattice">Data Flow Analysis Framework via Lattice</h3>
<p>一个数据流分析框架（D, L, F）由以下元素组成：</p>
<ul>
<li>D: 数据流的方向，前向还是后向</li>
<li>L: 包含了数据值 V 和 meet, join 符号的格（一般选其一，也就是半格）</li>
<li>F: V -&gt; V 的转移方程族</li>
</ul>
<p>从而，数据流分析可以被视为在 lattice 的值上迭代地应用转移方程和 meet/join 操作符。</p>
<h3 id="Monotonicity-and-Fixed-Point-Theorem">Monotonicity and Fixed Point Theorem</h3>
<p>回看我们在上面提出的问题：迭代算法在什么条件下可以停止？我们在这里引入不动点定理：</p>
<p>Monotonicity 单调性：如果$x \sqsubseteq y \Rightarrow f(x)\sqsubseteq f(y)$，则说函数f: L -&gt; L 是<strong>单调的</strong>。</p>
<p>FIxed Point Theorem 不动点定理：给定一个全格$(L,\sqsubseteq)$，如果：</p>
<ol>
<li>$f: L \rightarrow L$是单调的</li>
<li>$L$是有穷的</li>
</ol>
<p>也就是f单调有界+L全格，那么</p>
<ul>
<li>迭代$f^k(\bot)$可以得到最小不动点（least fixed point）</li>
<li>迭代$f^k(\top)$可以得到最大不动点（greatest fixed point）</li>
</ul>
<p>证明：</p>
<p>根据$\bot$和f的定义，我们可以得到：$\bot \sqsubseteq f(\bot)$。</p>
<p>由于 L 是有限的，且 f 单调，根据鸽笼原理，必然存在一个 k 使得$\bot \sqsubseteq f(\bot) \sqsubseteq f^2(\bot)\sqsubseteq …\sqsubseteq f^k(\bot)\sqsubseteq f^{k+1}(\bot) $，且$f^k(\bot) = f^{k+1}(\bot)$。</p>
<p>假设我们有另一个任意不动点 x，由于 f 是单调的，因此$f(\bot) \sqsubseteq f(x), f^2(\bot) \sqsubseteq f^2(x),…,f^{Fix} = f^k(\bot)\sqsubseteq f^k(x) = x$</p>
<p>可知的确$f^{Fix}$是最小不动点。</p>
<p>通过上面的证明，我们又回答了一个问题：如果我们的迭代算法符合不动点定理的要求，那么迭代得到的不动点，确实就是最优不动点。</p>
<p><img src="/2025/03/24/DFA-FD/不动点存在性证明.jpeg" alt="不动点存在性证明" style="zoom:33%;"><img src="/2025/03/24/DFA-FD/不动点least证明.jpeg" alt="不动点least证明" style="zoom:33%;"></p>
<h3 id="Relate-Iterative-Algorithm-to-Fixed-Point-Theorem">Relate Iterative Algorithm to Fixed Point Theorem</h3>
<p>以上我们只是定性的描述了是否能得到最优不动点，但是迭代算法怎样才能算是符合了不动点定理的要求呢？接下来介绍关联的方法。</p>
<p>首先，回想 fact 的形式：$(v_1^1,v_2^1,…,v_k^1)$，可以将其视为一个有限 lattice，它的积也是有限 lattice，因此 fact 对应到 finite lattice 是可以的。</p>
<p>然后，我们的迭代函数 F 包括了转移函数 f 和 join/meet 函数，证明 F 是单调的，那么也就能得到 $F: L\rightarrow L$ 是单调的。</p>
<p>这里分两部分。</p>
<ol>
<li>转移函数，即 $OUT = gen U (IN - kill)$，显然是单调的。</li>
<li>那么 join/meet 函数，我们要证明其单调，就是要证明：$\forall x,y,z\in L, x\sqsubseteq y$，有$x \sqcup z \sqsubseteq y \sqcup z$。
<ol>
<li>由定义，$y \sqsubseteq y \sqcup z$</li>
<li>由传递性，$x \sqsubseteq y \sqcup z$</li>
<li>则 $y \sqcup z$ 是 $x, z$ 的 lub</li>
<li>又 $x \sqcup z$ 是 $x, z$ 的 lub</li>
<li>因此 $x \sqcup z \sqsubseteq y \sqcup z$，证毕。</li>
</ol>
</li>
</ol>
<p>于是我们就完成了迭代算法到不动点定理的对应。</p>
<p>现在我们要回答本文开头的第三个问题了，什么时候算法停止？</p>
<p>这个问题就很简单了，因为每个 lattice 都有其高度。假设 lattice 的高度为 h，而我们的 CFG 节点数为 k，就算每次迭代可以使一个节点在 lattice 上升一个高度，那么最坏情况下，我们的迭代次数也就是 $i = h \times k$</p>
<p>最后我们再列出这三个问题与其回答：</p>
<ul>
<li>算法是否确保一定能停止/达到不动点？**能！**会不会总是有一个解答？<strong>可以！</strong></li>
<li>如果能到达不动点，那么是不是只有一个不动点？**可以有很多。**如果有多个不动点，我们的结果是最优的吗？<strong>是的！</strong></li>
<li>什么时候我们会能得到不动点？<strong>最坏情况下，是 lattice 的高度与 CFG 的节点数的乘积。</strong></li>
</ul>
<h3 id="May-Must-Analysis-A-Lattice-View">May/Must Analysis, A Lattice View</h3>
<p>无论 may 还是 must 分析，都是从一个方向到另一个方向去走。考虑我们的 lattice 抽象成这样一个视图。</p>
<p>例如，对于到达定值分析，下界代表没有任何可到达的定值，上界代表所有定值都可到达。</p>
<p>下界代表 unsafe 的情形，即我们认为无到达定值，可对相关变量的存储空间进行替换。上界代表 safe but useless 的情形，即认为定值必然到达，但是这对我们寻找一个可替换掉的存储空间毫无意义。</p>
<p>而因为我们采用了 join 函数，那么我们必然会从 lattice 的最小下界往上走。而越往上走，我们就会失去更多的精确值。那么，在所有不动点中我们寻找最小不动点，那么就能得到精确值最大的结果。</p>
<p>反之，在可用表达式分析中，下界代表无可用表达式，上界代表所有表达式都可用。</p>
<p>下界代表 safe but useless 的情形，因为需要重新计算每个表达式，即使确实有表达式可用。而上界代表 unsafe，因为不是所有路径都能使表达式都可用。与 may analysis 一样，通过寻找最大不动点，我们能得到合法的结果中精确值最大的结果。</p>
<img src="/2025/03/24/DFA-FD/May:Must Analysis.jpeg" alt="May:Must Analysis" style="zoom:50%;">
<h3 id="Distributivity-and-MOP">Distributivity and MOP</h3>
<p>我们引入 Meet-Over-All-Paths Solution，即 MOP。在这个 solution 中，我们不是根据节点与其前驱/后继节点的关系来迭代计算数据流，而是直接查找所有路径，根据所有路径的计算结果再取上/下界。这个结果是最理想的结果。</p>
<p><img src="/2025/03/24/DFA-FD/mop.png" alt="mop"></p>
<p>可以看到，迭代算法是 s3 对前驱取 join 后进行进行 f3 的转移，而 MOP 算法是对到达 s3 之后，s4 之前的路径结果取 join。</p>
<p>那么迭代算法和 MOP 哪个更精确呢？我们可以证明，$F(x)\sqcup F(y)\sqsubseteq F(x\sqcup y)$：</p>
<img src="/2025/03/24/DFA-FD/IAvsMOP.jpeg" alt="IAvsMOP" style="zoom:33%;">
<p>这表明 MOP 是更为精确的。</p>
<p>但这并没有结束。而如果 F 是可分配的，那么确实可以让偏序符号改为等于号。恰好，gen/kill problem 下，F 确实可分配因此我们能确定，迭代算法的精度与 MOP 相等。</p>
<h3 id="Constant-Propagation">Constant Propagation</h3>
<p>当然有些问题下 F 是不可分配的，如常量传播（Constant Propagation）。</p>
<img src="/2025/03/24/DFA-FD/常量传播.jpeg" alt="常量传播" style="zoom:33%;">
<p>在常量传播分析中，其最大上界是 undefine，因为我们不知道一个变量到底被定义为了什么值。最小下界是 NAC（Not A Constant），而中间就是各种常量。这是因为分析一个变量指向的值是否为常量，那么要么它是同一个值，要么它不是常量。</p>
<p>给定一个 statement s: x = …，我们定义转移函数$OUT[s]=gen\cup(IN[s]-{(x,_)})$。</p>
<p>其中我们根据赋值号右边的不同，决定不同的 gen 函数：</p>
<img src="/2025/03/24/DFA-FD/gen 函数.jpeg" alt="gen 函数" style="zoom:25%;">
<p>注意，const + undef -&gt; undef。因为 undef 变成 const 的过程中是降级，而如果 const1 + undef -&gt; const2，那么 undef 变化为 const 时，const2 会发生改变，原来的 const2 与现在的 const2 不具有偏序关系，那么就不满足偏序关系的单调性了。</p>
<p>常量传播是不可分配的。以下图为例：对于 c，$F(X)\sqcap F(Y) = 10, F(X\sqcap Y) = \text{NAC}$</p>
<img src="/2025/03/24/DFA-FD/常量传播不可分配例子.jpeg" alt="常量传播不可分配例子" style="zoom:25%;">
<h3 id="Worklist-Algorithm">Worklist Algorithm</h3>
<p>在 Worklist 算法中，只在基本块的 fact 发生变化处理其相关基本块，不必再在每次有 fact 变化时处理所有的基本块了。原来算法的优化，比较简单。</p>
<img src="/2025/03/24/DFA-FD/Worklist Algorithm.jpeg" alt="Worklist Algorithm" style="zoom: 33%;">
<h3 id="划重点">划重点</h3>
<ul>
<li>理解函数视角下的迭代算法</li>
<li>对于 lattice 和 complete lattice 的定义</li>
<li>理解不动点定理</li>
<li>知道如何用 lattice 来概述 may 和 must analysis</li>
<li>MOP与迭代算法结果之间的关系</li>
<li>常量传播分析</li>
<li>Worklist 算法</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>SPA</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2025/03/24/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start">Quick Start</h2>
<h3 id="Create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
